<resources>
    <string name="app_name">8 Puzzle</string>
    <string name="home">Home</string>
    <string name="solver">Solver</string>
    <string name="info">Info</string>
    <string name="how_to_play_instructions">Move the tiles into the blank space to make the pattern
        shown above, by tapping on the tile you want to move.</string>
    <string name="info_description">The 8-Puzzle was invented by Noyes Palmer Chapman around 1874.
        It was originally a 4-by-4 grid, and called the 15-Puzzle. This is a simplified 3-by-3 version. </string>
    <string name="how_to_play">How To Play</string>
    <string name="help">Help</string>
    <string name="solved">Solved!</string>
    <string name="scramble">Scramble</string>
    <string name="reset">Reset</string>
    <string name="solver_instructions">Fill in the numbers to solve, leaving the empty space blank.</string>
    <string name="solve">Solve</string>
    <string name="solver_algorithm_description">
       The solver finds the minimum number of moves (the least-cost path) to solve a random input
        puzzle, using the A* graph searching algorithm, which uses heuristics to guide its search
        (a best-first search). The heuristic in this algorithm uses the manhattan distance, which
        is the sum of the displacements of each tile from its solved state.
        \n\n
        The heuristic function in this algorithm uses the sum of the manhattan distance and the
        number of moves made so far. Intuitively, a move that results in a puzzle with tiles closer
        to the solved puzzle, and that reaches this state with the least number of moves is the
        best one.
        \n\n
    The algorithm is implemented using search nodes containing the puzzle state, its priority, and
        the previous search node. Because each new search node from a new board configuration is
        the parent of all its neighbouring search nodes, the algorithm essentially uses a tree of
        paths rooted at the starting position. At each step, all possible search nodes containing
        adjacent puzzle instances are added to the tree (with their respective priorities), and the
        one with lowest priority is removed. Once the solved puzzle is reached, the steps are
        retraced by calling each node\'s previous search node.
        \n\n
    An algorithm is guaranteed to be optimal if its heuristic is admissible; i.e., the heuristic
        never overestimates the actual solution\'s length. Because the algorithm continues to search
        the lowest priority puzzle state (not necessarily in any order) until the goal state is
        reached with lowest priority, the route it took to reach the goal must be the optimal
        solution.
    </string>
    <string name="solver_algorithm">Solver Algorithm</string>
    <string name="credits">Created with Kotlin by Calvin Liu, 2020</string>
    <string name="puzzle_solver_steps">Puzzle Solver Steps:</string>
    <string name="steps">"Steps: %1$d"</string>
    <string name="solver_input_hint">0</string>
    <string name="solver_input_error_syntax">Please only enter numbers between 1 and 8.</string>
    <string name="solver_input_error_repeats">Please only use each of the numbers from 1 to 8 once.</string>
</resources>